{"version":3,"sources":["../src/fs/types.ts","../src/fs/index.ts","../src/fs/idbfs.ts","../src/fs/pgfs.ts","../src/fs/memoryfs.ts"],"sourcesContent":["import type { EmPostgres, FS } from \"../postgres.js\";\n\nexport type FsType = \"nodefs\" | \"idbfs\" | \"memoryfs\" | \"pgfs\";\n\nexport interface FilesystemFactory {\n  new (dataDir: string): Filesystem;\n}\n\nexport interface Filesystem {\n  /**\n   * Returns the options to pass to the emscripten module.\n   */\n  emscriptenOpts(opts: Partial<EmPostgres>): Promise<Partial<EmPostgres>>;\n\n  /**\n   * Sync the filesystem to the emscripten filesystem.\n   */\n  syncToFs(mod: FS): Promise<void>;\n\n  /**\n   * Sync the emscripten filesystem to the filesystem.\n   */\n  initialSyncFs(mod: FS): Promise<void>;\n\n\n//  on_mount(): Function<void>;\n  // load_extension(ext: string): Promise<void>;\n\n}\n\nexport abstract class FilesystemBase implements Filesystem {\n  protected dataDir?: string;\n  constructor(dataDir?: string) {\n    this.dataDir = dataDir;\n  }\n  abstract emscriptenOpts(\n    opts: Partial<EmPostgres>,\n  ): Promise<Partial<EmPostgres>>;\n  async syncToFs(mod: FS) {}\n  async initialSyncFs(mod: FS) {}\n}\n","import type { FsType } from \"./types.js\";\nimport { IdbFs } from \"./idbfs.js\";\nimport { PgFs } from \"./pgfs.js\";\nimport { MemoryFS } from \"./memoryfs.js\";\n\n\nexport type * from \"./types.js\";\n\nexport const WASM_PREFIX = \"/tmp/pglite\";\n// default for non web runtimes is /tmp/pglite/base\nexport var PGDATA = \"WASM_PREFIX\" + \"/\" + \"base\";\n\nfunction getBase(dataDir : string | undefined) {\n    if (!dataDir || (dataDir.length <= 1)) {\n      throw new Error(\"Invalid dataDir, only a namespace required for pgfs and not a path\");\n    }\n    dataDir = dataDir.split(\"/\").pop()\n    PGDATA = WASM_PREFIX + \"/\" + dataDir\n    return dataDir\n}\n\nexport function parseDataDir(dataDir?: string) {\n  let fsType: FsType;\n  if (dataDir?.startsWith(\"file://\")) {\n    // Remove the file:// prefix, and use node filesystem\n    dataDir = dataDir.slice(7);\n    if (!dataDir) {\n      throw new Error(\"Invalid dataDir, must be a valid path\");\n    }\n    fsType = \"nodefs\";\n  } else if (dataDir?.startsWith(\"pg://\")) {\n    // Remove the pg:// prefix, no / allowed in dbname, and use custom filesystem\n    dataDir = getBase( dataDir.slice(5) )\n    fsType = \"pgfs\";\n  } else if (dataDir?.startsWith(\"idb://\")) {\n    // Remove the idb:// prefix, and use indexeddb filesystem\n    dataDir = getBase( dataDir.slice(6) )\n    fsType = \"idbfs\";\n  } else if (!dataDir || dataDir?.startsWith(\"memory://\")) {\n    // Use in-memory filesystem\n    fsType = \"memoryfs\";\n  } else {\n    // No prefix, use node filesystem\n    fsType = \"nodefs\";\n  }\n  return { dataDir, fsType };\n}\n\nexport async function loadFs(dataDir?: string, fsType?: FsType) {\n  if (dataDir && fsType === \"nodefs\") {\n    // Lazy load the nodefs to avoid bundling it in the browser\n    const { NodeFS } = await import(\"./nodefs.js\");\n    return new NodeFS(dataDir);\n  } else if (dataDir && fsType === \"idbfs\") {\n    return new IdbFs(dataDir);\n  } else if (dataDir && fsType === \"pgfs\") {\n    return new PgFs(dataDir);\n  } else {\n    return new MemoryFS();\n  }\n}\n","import { FilesystemBase } from \"./types.js\";\nimport type { FS, EmPostgres } from \"../postgres.js\";\nimport { PGDATA } from \"./index.js\";\n\nexport class IdbFs extends FilesystemBase {\n  async emscriptenOpts(opts: Partial<EmPostgres>) {\n    const options: Partial<EmPostgres> = {\n      ...opts,\n      preRun: [\n        ...(opts.preRun || []),\n        (mod: any) => {\n          const idbfs = mod.FS.filesystems.IDBFS;\n          // Mount the idbfs to the users dataDir then symlink the PGDATA to the\n          // idbfs mount point.\n          // We specifically use /pglite as the root directory for the idbfs\n          // as the fs will ber persisted in the indexeddb as a database with\n          // the path as the name.\n          mod.FS.mkdir(`/pglite`);\n          mod.FS.mkdir(`/pglite/${this.dataDir}`);\n          mod.FS.mount(idbfs, {}, `/pglite/${this.dataDir}`);\n          mod.FS.symlink(`/pglite/${this.dataDir}`, PGDATA);\n        },\n      ],\n    };\n    return options;\n  }\n\n  initialSyncFs(fs: FS) {\n    return new Promise<void>((resolve, reject) => {\n      fs.syncfs(true, (err: any) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  syncToFs(fs: FS) {\n    return new Promise<void>((resolve, reject) => {\n      fs.syncfs(false, (err: any) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n}\n","import { FilesystemBase } from \"./types.js\";\nimport type { FS, EmPostgres } from \"../postgres.js\";\nimport { PGDATA } from \"./index.js\";\n\nexport class PgFs extends FilesystemBase {\n  //initModule?: any;\n\n  async emscriptenOpts(opts: Partial<EmPostgres>) {\n    const options: Partial<EmPostgres> = {\n      ...opts,\n      preRun: [\n        (mod: any) => {\n          const pgfs = mod.FS.filesystems.PGFS;\n          // Mount the pgfs to PGDATA in auto commit mode\n          mod.FS.mkdir(PGDATA);\n          mod.FS.mount(pgfs, {autoPersist: false}, `/tmp/pglite/${this.dataDir}`);\n        },\n      ],\n    };\n    return options;\n  }\n\n  initialSyncFs(fs: FS) {\n    return new Promise<void>((resolve, reject) => {\n      fs.syncfs(true, (err: any) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  syncToFs(fs: FS) {\n    return new Promise<void>((resolve, reject) => {\n      fs.syncfs(false, (err: any) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n}\n","import { FilesystemBase } from \"./types.js\";\nimport type { EmPostgres } from \"../postgres.js\";\n\nexport class MemoryFS extends FilesystemBase {\n  async emscriptenOpts(opts: Partial<EmPostgres>) {\n    // Nothing to do for memoryfs\n    return opts;\n  }\n}\n"],"mappings":"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","names":["init_buffer","FilesystemBase","dataDir","mod","init_buffer","init_buffer","IdbFs","FilesystemBase","opts","mod","idbfs","PGDATA","fs","resolve","reject","err","init_buffer","PgFs","FilesystemBase","opts","mod","pgfs","PGDATA","fs","resolve","reject","err","init_buffer","MemoryFS","FilesystemBase","opts","WASM_PREFIX","PGDATA","getBase","dataDir","parseDataDir","fsType","loadFs","NodeFS","IdbFs","PgFs","MemoryFS"]}